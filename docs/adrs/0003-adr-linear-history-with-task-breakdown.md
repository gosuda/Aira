# ADR-0003: ADR Linear History with Task Breakdown

## Status

Accepted

## Date

2026-02-17

## Context

Aira's core value proposition is making AI agent work transparent and reviewable. When AI agents execute development tasks, they make architectural decisions (library choices, data model designs, API contracts) that humans need to understand, review, and potentially override. Without structured decision records, these choices are buried in code diffs and chat logs, making it impossible to answer "why was this built this way?" after the fact.

Key forces:

- **Decision transparency** requires structured records that capture the reasoning behind each architectural choice, not just the code change.
- **Actionable work items** must be derived from decisions so humans can track progress on a kanban board.
- **Append-only history** is necessary to maintain an audit trail: decisions should never be silently edited or deleted.
- **Real-time visibility** is required: humans watching the kanban board need to see decisions and tasks appear as agents work, not after batch processing.
- **Agent authorship** means the records are generated by AI, requiring structure enforcement to ensure consistent quality.

## Decision

Implement a **two-level model** for decision tracking:

1. **ADR (Architectural Decision Record) level:** Decisions stored as an append-only linear timeline in PostgreSQL. Each ADR has a unique sequence number, title, context, decision rationale, alternatives considered, and consequences. ADRs are created by AI agents during execution via the `create_adr` MCP tool and supplemented by post-processing extraction (see ADR-0007). ADRs are immutable once created; superseding decisions reference the original ADR.

2. **Task level:** Actionable work items broken down from each ADR. Tasks are displayed in a 4-state kanban board: `Backlog`, `In Progress`, `In Review`, `Done`. Each task references its parent ADR via foreign key. Tasks can be created by agents during execution or by humans reviewing ADR decisions.

The kanban board UI displays tasks grouped by their parent ADR, providing both the "what" (tasks) and the "why" (ADR context) in a single view.

## Alternatives Considered

### Alternative 1: Git-only ADRs (Markdown files in repository)

- Store ADRs as markdown files in a `docs/adrs/` directory within the repository, following the traditional ADR convention.
- **Rejected because:** Git-only storage prevents real-time kanban board updates (requires cloning the repo to read decisions). No structured query capability for filtering, searching, or aggregating decisions across projects. Agents would need git commit access just to record decisions, coupling decision recording to code delivery.

### Alternative 2: Flat task list (no ADR hierarchy)

- Store tasks directly without grouping them under architectural decisions.
- **Rejected because:** Loses the decision context that explains why tasks exist. A flat list of "add Redis caching" and "update API handler" gives no insight into why those changes were chosen. Reviewing agent work becomes reviewing individual changes rather than understanding strategic decisions.

### Alternative 3: Customizable kanban columns

- Allow users to define arbitrary kanban column names and states per project.
- **Rejected because:** Over-engineering for MVP. Customizable columns require state machine configuration, migration handling when columns change, and validation logic for allowed transitions. The fixed 4-state model (`Backlog` -> `In Progress` -> `In Review` -> `Done`) covers the required workflow and can be extended later if user feedback demands it.

## Consequences

### Positive

- Clean separation between "why" (ADRs) and "what" (tasks) enables different review workflows: architects review ADRs, developers review tasks.
- Agents auto-generate ADRs as they work, creating an audit trail without human effort.
- Humans review a decision timeline rather than individual code changes, making agent work comprehensible at a strategic level.
- Append-only ADR history provides a reliable audit trail for compliance and post-mortems.
- Task-ADR linkage enables impact analysis: "if we revert this decision, which tasks are affected?"

### Negative

- Two-level model is more complex to query than a flat structure: listing "all work items" requires joining tasks with their parent ADRs.
- The ADR-task relationship must be maintained consistently: orphaned tasks (no parent ADR) or empty ADRs (no derived tasks) reduce the model's value.
- Risk of duplicate ADRs when both the explicit tool call and post-processing extraction capture the same decision (mitigated by dedup logic in ADR-0007).

### Neutral

- The 4-state kanban model is intentionally simple and may need extension (e.g., `Blocked` state) based on user feedback.
- ADR sequence numbers are project-scoped, not globally unique, to keep numbering human-readable.

## References

- [MADR - Markdown Any Decision Records](https://adr.github.io/madr/)
- [Documenting Architecture Decisions (Michael Nygard)](https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions)
- ADR-0007: Hybrid ADR Creation (Agent Tool + Post-Processing)
